import { createSignal, createMemo, For, Show } from 'solid-js';
import { Editor } from './components/Editor';
import { AstViewer } from './components/AstViewer';
import { OutputPanel } from './components/OutputPanel';

// Placeholder types until WASM bindings are ready
type AstNode = {
  type: string;
  value?: string | number;
  children?: AstNode[];
};

type ParseResult =
  | { ok: true; ast: AstNode }
  | { ok: false; error: string };

// Mock parser until WASM is ready
function mockParse(input: string): ParseResult {
  if (!input.trim()) {
    return { ok: false, error: 'Empty expression' };
  }

  // Very basic mock AST for demonstration
  const trimmed = input.trim();

  // Simple number
  if (/^-?\d+(\.\d+)?$/.test(trimmed)) {
    return {
      ok: true,
      ast: { type: 'Num', value: parseFloat(trimmed) }
    };
  }

  // Simple variable
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(trimmed)) {
    return {
      ok: true,
      ast: { type: 'Var', value: trimmed }
    };
  }

  // Binary expression (very naive)
  const binMatch = trimmed.match(/^(.+?)\s*([+\-*/^])\s*(.+)$/);
  if (binMatch) {
    const leftResult = mockParse(binMatch[1]);
    const rightResult = mockParse(binMatch[3]);

    if (!leftResult.ok) return leftResult;
    if (!rightResult.ok) return rightResult;

    const opMap: Record<string, string> = {
      '+': 'Add', '-': 'Sub', '*': 'Mul', '/': 'Div', '^': 'Pow'
    };

    return {
      ok: true,
      ast: {
        type: 'BinOp',
        value: opMap[binMatch[2]] || binMatch[2],
        children: [leftResult.ast, rightResult.ast]
      }
    };
  }

  // Function call
  const fnMatch = trimmed.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*)?\)$/);
  if (fnMatch) {
    const args = fnMatch[2] ? fnMatch[2].split(',').map(a => a.trim()) : [];
    const argResults = args.map(mockParse);
    const firstError = argResults.find(r => !r.ok);
    if (firstError && !firstError.ok) return firstError;

    return {
      ok: true,
      ast: {
        type: 'Call',
        value: fnMatch[1],
        children: argResults.filter((r): r is { ok: true; ast: AstNode } => r.ok).map(r => r.ast)
      }
    };
  }

  return { ok: false, error: `Unable to parse: ${trimmed}` };
}

export function App() {
  const [expression, setExpression] = createSignal('sin(x) + cos(y) * 2');
  const [activeTab, setActiveTab] = createSignal<'ast' | 'wgsl' | 'lua'>('ast');

  const parseResult = createMemo(() => mockParse(expression()));

  const mockWgsl = createMemo(() => {
    const result = parseResult();
    if (!result.ok) return null;
    // Placeholder - will be generated by WASM
    return `// WGSL output (placeholder)\nfn expr(x: f32, y: f32) -> f32 {\n  return ${expression()};\n}`;
  });

  const mockLua = createMemo(() => {
    const result = parseResult();
    if (!result.ok) return null;
    // Placeholder - will be generated by WASM
    return `-- Lua output (placeholder)\nfunction expr(x, y)\n  return ${expression()}\nend`;
  });

  return (
    <div class="playground">
      <header class="playground__header">
        <h1 class="playground__title">Dew Playground</h1>
        <div class="controls">
          <div class="control-group">
            <span class="control-group__label">Features:</span>
            <button class="toggle toggle--active">cond</button>
            <button class="toggle toggle--active">func</button>
          </div>
        </div>
      </header>

      <main class="playground__main">
        <div class="panel">
          <div class="panel__header">
            Expression
          </div>
          <div class="panel__content panel__content--no-padding">
            <Editor
              value={expression()}
              onChange={setExpression}
              placeholder="Enter a dew expression..."
            />
          </div>
        </div>

        <div class="panel">
          <div class="panel__header">
            <span>Output</span>
            <div class="tabs">
              <button
                class={`tabs__tab ${activeTab() === 'ast' ? 'tabs__tab--active' : ''}`}
                onClick={() => setActiveTab('ast')}
              >
                AST
              </button>
              <button
                class={`tabs__tab ${activeTab() === 'wgsl' ? 'tabs__tab--active' : ''}`}
                onClick={() => setActiveTab('wgsl')}
              >
                WGSL
              </button>
              <button
                class={`tabs__tab ${activeTab() === 'lua' ? 'tabs__tab--active' : ''}`}
                onClick={() => setActiveTab('lua')}
              >
                Lua
              </button>
            </div>
          </div>
          <div class="panel__content">
            <Show when={parseResult().ok} fallback={
              <div class="output__value output__value--error">
                {(parseResult() as { ok: false; error: string }).error}
              </div>
            }>
              <Show when={activeTab() === 'ast'}>
                <AstViewer ast={(parseResult() as { ok: true; ast: AstNode }).ast} />
              </Show>
              <Show when={activeTab() === 'wgsl'}>
                <pre class="code-block">{mockWgsl()}</pre>
              </Show>
              <Show when={activeTab() === 'lua'}>
                <pre class="code-block">{mockLua()}</pre>
              </Show>
            </Show>
          </div>
        </div>
      </main>
    </div>
  );
}
